package engine;
import java.util.TreeSet;
/**
 * This class implements a custom data structure which is used to hold and
 * track the generated numbers. This class is thread-safe.
 * @author Balwinder Sodhi
 */
class NumbersTracker { 

	/**
	 * Set that holds the generated numbers.
	 */
	private TreeSet<Long> set;
	/**
	 * Set used to track removed numbers. This is needed because there are
	 * multiple threads which will be removing numbers from generated number's
	 * set, and we want to ensure that duplicates are tracked correctly.
	 */
	private TreeSet<Long> removedItems = new TreeSet<Long>();
	/**
	 * How many unique generated numbers we know of.
	 */
	private volatile int knownCount = 0;
	/**
	 * This is the target count of unique generated numbers we want to find. 
	 */
	private int targetIndex;
	/**
	 * This number tracks the dynamically adjusted upper bound on the generated
	 * number's value. We use it to limit the work.
	 */
	private long tooBig = Long.MAX_VALUE;
	/**
	 * Flag that indicates whether to print progress of numbers generation.
	 */
	private boolean printProgress;

	/**
	 * C'tor which initializes the class fields.
	 * @param seed Initial seed number.
	 * @param target Target count of unique generated numbers we want to find.
	 */
	public NumbersTracker(long seed, int target, boolean printProgress) {

		set = new TreeSet<Long>();
		set.add(Long.valueOf(seed));
		targetIndex = target - 1;
		this.printProgress = printProgress;
	}

	/**
	 * Checks whether the set of generated numbers is empty.
	 * @return true if empty, else false.
	 */
	public synchronized boolean isEmpty() {
		return set.isEmpty();
	}

	/**
	 * Adds a supplied number to the generated numbers set. We check the
	 * set of removed numbers to ensure that:
	 * <pre>
	 * 1. The new number has not already been removed, possibly by a different thread
	 * 2. Generated numbers set doesn't already contain the new number
	 * </pre>
	 * If the number is added to the generated numbers set then we also
	 * adjust the upper bound on target number's value.
	 * @param n Number to be added.
	 */
	public synchronized void addNumber(long n) {
		/**
		 * If this number was found earlier by some worker,
		 * then later removed by another one then we don't
		 * do anything and simply return. 
		 */
		if (removedItems.contains(n)) {
			return;
		} 
		/**
		 * Else if this number was not already present in the list
		 * then we add it, and also try adjusting the upper bound
		 * on the target number.
		 */
		if (set.add(Long.valueOf(n))) {
			
			// Adjust the upper bound on the target number
			if (knownCount++ > targetIndex) {
				tooBig = set.last(); // Lower the tooBig
				set.remove(tooBig); // Remove the tail
			}
		}
	}

	/**
	 * Removes the first number from the generated numbers set and adds it
	 * to the removed numbers set.
	 * @return The removed number.
	 */
	public synchronized long takeFirst() {
		Long obj = set.first();
		set.remove(obj);
		/**
		 * We want to keep track of what's removed because
		 * there are multiple threads adding and removing
		 */
		removedItems.add(obj);
		
		// If asked, print the progress of where we are
		if (printProgress) printProgress(removedItems.size());
		
		return obj;
	}

	/**
	 * Returns the current value of upper bound on target number's value. 
	 * @return Current value of upper bound on target number's value.
	 */
	public synchronized long getTooBig() {
		return tooBig;
	}

	/**
	 * Resulting target number generated by this program. 
	 * @return Target number generated by this program.
	 */
	public long getResultingTargetNumber() {
		return removedItems.last();
	}

	/**
	 * Prints the progress of number generation in chunks of 1000.
	 * @param count Current count of generated numbers.
	 */
	private void printProgress(int count) {
		if (count % 1000 == 0) {
			System.out.println(Utils.currentTime()+ ":: Processed "+count+" numbers.");
		}
	}
	
	/**
	 * This method checks whether we have generated the target number. We'd have
	 * generated the target number if:
	 * <pre> 
	 * 1. The next number that we are trying to add is bigger than the current
	 * limit AND 
	 * 2. We have removed all the existing numbers from the generated list,
	 * which means that we have started the tasks for each of those numbers
	 * and they should complete sometime.
	 * </pre>
	 * @param nextNumber The new generated number we are trying to add to the
	 * generated number's set
	 * @return true if we are done, else false.
	 */
	public synchronized boolean isDone(long nextNumber) {
		return nextNumber > tooBig && set.isEmpty();
	}
}
